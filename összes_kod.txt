===== main.py =====
from fastapi import FastAPI, Depends
from contextlib import asynccontextmanager
from .core.config import get_settings
from .core.database import Base, engine
from .api.router import api_router
from .plugins.loader import PluginLoader
from sqlalchemy.orm import Session
from .core.database import get_db
from fastapi_mcp import FastApiMCP
from fastapi.middleware.cors import CORSMiddleware

# Create database tables
Base.metadata.create_all(bind=engine)

# Instantiate settings
settings = get_settings()

# Define lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup actions
    db = next(get_db())
    try:
        plugin_loader = PluginLoader()
        plugin_loader.load_plugins(db)
    finally:
        db.close()
    yield
    # (Optional) Shutdown actions can be placed after yield if needed

# Create FastAPI app
app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# Include API router
app.include_router(api_router, prefix=settings.API_V1_STR)


app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Add MCP
mcp = FastApiMCP(app)
mcp.mount()

# Root endpoint
@app.get("/")
async def root():
    return {
        "name": settings.PROJECT_NAME,
        "docs": "/docs",
        "api_base": settings.API_V1_STR
    }


===== __init__.py =====


===== router.py =====
from fastapi import APIRouter
from .endpoints import devices, standard, custom, plugins, sensors

api_router = APIRouter()

# Include all API endpoint routers
api_router.include_router(devices.router, prefix="/devices", tags=["devices"])
api_router.include_router(standard.router, prefix="/standard", tags=["standard"])
api_router.include_router(custom.router, prefix="/custom", tags=["custom"])
api_router.include_router(plugins.router, prefix="/plugins", tags=["plugins"])
api_router.include_router(sensors.router, prefix="/sensors", tags=["sensors"])


===== __init__.py =====


===== custom.py =====
from fastapi import APIRouter, Depends, Path, Body, HTTPException
from sqlalchemy.orm import Session
from typing import Dict, Any

from ...core.database import get_db
from ...services.custom_service import CustomDeviceService

router = APIRouter()

@router.get("/{device_id}/status", operation_id="get_custom_device_status")
async def get_device_status(
    device_id: int = Path(..., description="The ID of the custom device"),
    db: Session = Depends(get_db)
):
    """
    Get status from a custom device using its plugin.
    """
    return await CustomDeviceService.get_device_status(db, device_id)

@router.get("/{device_id}/metrics", operation_id="get_custom_device_metrics")
async def get_device_metrics(
    device_id: int = Path(..., description="The ID of the custom device"),
    db: Session = Depends(get_db)
):
    """
    Get metrics from a custom device using its plugin.
    """
    return await CustomDeviceService.get_device_metrics(db, device_id)

@router.post("/{device_id}/operations/{operation_id}", operation_id="execute_custom_device_operation")
async def execute_operation(
    device_id: int = Path(..., description="The ID of the custom device"),
    operation_id: str = Path(..., description="The ID of the operation to execute"),
    params: Dict[str, Any] = Body({}, description="Parameters for the operation"),
    db: Session = Depends(get_db)
):
    """
    Execute a custom operation on a device.
    """
    return await CustomDeviceService.execute_operation(db, device_id, operation_id, params)


===== devices.py =====
from fastapi import APIRouter, Depends, Path, Query, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional

from ...core.database import get_db
from ...schemas.device import DeviceCreate, DeviceResponse, DeviceUpdate, StandardDeviceUpdate, CustomDeviceUpdate
from ...services.device_service import DeviceService

router = APIRouter()

@router.get("/", response_model=List[DeviceResponse], operation_id="get_all_devices")
async def get_devices(
    skip: int = Query(0, description="Skip first N devices"),
    limit: int = Query(100, description="Limit the number of devices returned"),
    db: Session = Depends(get_db)
):
    """
    Get all devices with pagination.
    """
    return await DeviceService.get_devices(db, skip=skip, limit=limit)

@router.get("/{device_id}", response_model=DeviceResponse, operation_id="get_device_by_id")
async def get_device(
    device_id: int = Path(..., description="The ID of the device to get"),
    db: Session = Depends(get_db)
):
    """
    Get a device by ID.
    """
    return await DeviceService.get_device(db, device_id)

@router.post("/", response_model=DeviceResponse, operation_id="create_new_device")
async def create_device(
    device: DeviceCreate,
    db: Session = Depends(get_db)
):
    """
    Create a new device (standard or custom).
    """
    return await DeviceService.create_device(db, device)

@router.put("/{device_id}", response_model=DeviceResponse, operation_id="update_device")
async def update_device(
    device_data: DeviceUpdate,
    device_id: int = Path(..., description="The ID of the device to update"),
    standard_data: Optional[StandardDeviceUpdate] = None,
    custom_data: Optional[CustomDeviceUpdate] = None,
    db: Session = Depends(get_db)
):
    """
    Update a device and its associated details.
    """
    return await DeviceService.update_device(
        db,
        device_id,
        device_data,
        standard_data=standard_data,
        custom_data=custom_data
    )

@router.delete("/{device_id}", operation_id="delete_device")
async def delete_device(
    device_id: int = Path(..., description="The ID of the device to delete"),
    db: Session = Depends(get_db)
):
    """
    Delete a device.
    """
    result = await DeviceService.delete_device(db, device_id)
    if result:
        return {"message": f"Device with ID {device_id} deleted successfully"}
    return {"message": f"Failed to delete device with ID {device_id}"}


===== plugins.py =====
from fastapi import APIRouter, Depends, Path, Query, HTTPException, Body
from sqlalchemy.orm import Session
from typing import List

from ...core.database import get_db
from ...schemas.plugin import PluginCreate, PluginResponse, PluginUpdate
from ...services.plugin_service import PluginService

router = APIRouter()

@router.get("/", response_model=List[PluginResponse], operation_id="get_all_plugins")
async def get_plugins(
    skip: int = Query(0, description="Skip first N plugins"),
    limit: int = Query(100, description="Limit the number of plugins returned"),
    db: Session = Depends(get_db)
):
    """
    Get all plugins with pagination.
    """
    return await PluginService.get_plugins(db, skip=skip, limit=limit)

@router.get("/{plugin_id}", response_model=PluginResponse, operation_id="get_plugin_by_id")
async def get_plugin(
    plugin_id: int = Path(..., description="The ID of the plugin to get"),
    db: Session = Depends(get_db)
):
    """
    Get a plugin by ID.
    """
    return await PluginService.get_plugin(db, plugin_id)

@router.post("/", response_model=PluginResponse, operation_id="create_new_plugin")
async def create_plugin(
    plugin: PluginCreate,
    db: Session = Depends(get_db)
):
    """
    Create a new plugin after validating the code.
    """
    return await PluginService.create_plugin(db, plugin)

@router.put("/{plugin_id}", response_model=PluginResponse, operation_id="update_plugin")
async def update_plugin(
    plugin_data: PluginUpdate,
    plugin_id: int = Path(..., description="The ID of the plugin to update"),
    db: Session = Depends(get_db)
):
    """
    Update a plugin after validating the code if provided.
    """
    return await PluginService.update_plugin(db, plugin_id, plugin_data)

@router.delete("/{plugin_id}", operation_id="delete_plugin")
async def delete_plugin(
    plugin_id: int = Path(..., description="The ID of the plugin to delete"),
    db: Session = Depends(get_db)
):
    """
    Delete a plugin.
    """
    result = await PluginService.delete_plugin(db, plugin_id)
    if result:
        return {"message": f"Plugin with ID {plugin_id} deleted successfully"}
    return {"message": f"Failed to delete plugin with ID {plugin_id}"}


===== sensors.py =====
from fastapi import APIRouter, Depends, Path, Query, HTTPException
from sqlalchemy.orm import Session
from typing import List

from ...core.database import get_db
from ...schemas.sensor import SensorCreate, SensorResponse, SensorUpdate, AlertCreate, AlertResponse
from ...services.sensor_service import SensorService

router = APIRouter()

@router.get("/", response_model=List[SensorResponse], operation_id="get_all_sensors")
async def get_sensors(
    skip: int = Query(0, description="Skip first N sensors"),
    limit: int = Query(100, description="Limit the number of sensors returned"),
    db: Session = Depends(get_db)
):
    """
    Get all sensors with pagination.
    """
    return await SensorService.get_sensors(db, skip=skip, limit=limit)

@router.get("/device/{device_id}", response_model=List[SensorResponse], operation_id="get_device_sensors")
async def get_device_sensors(
    device_id: int = Path(..., description="The ID of the device"),
    db: Session = Depends(get_db)
):
    """
    Get all sensors for a specific device.
    """
    return await SensorService.get_device_sensors(db, device_id)

@router.get("/{sensor_id}", response_model=SensorResponse, operation_id="get_sensor_by_id")
async def get_sensor(
    sensor_id: int = Path(..., description="The ID of the sensor to get"),
    db: Session = Depends(get_db)
):
    """
    Get a sensor by ID.
    """
    return await SensorService.get_sensor(db, sensor_id)

@router.post("/", response_model=SensorResponse, operation_id="create_new_sensor")
async def create_sensor(
    sensor: SensorCreate,
    db: Session = Depends(get_db)
):
    """
    Create a new sensor.
    """
    return await SensorService.create_sensor(db, sensor)

@router.put("/{sensor_id}", response_model=SensorResponse, operation_id="update_sensor")
async def update_sensor(
    sensor_data: SensorUpdate,
    sensor_id: int = Path(..., description="The ID of the sensor to update"),
    db: Session = Depends(get_db)
):
    """
    Update a sensor.
    """
    return await SensorService.update_sensor(db, sensor_id, sensor_data)

@router.delete("/{sensor_id}", operation_id="delete_sensor")
async def delete_sensor(
    sensor_id: int = Path(..., description="The ID of the sensor to delete"),
    db: Session = Depends(get_db)
):
    """
    Delete a sensor.
    """
    result = await SensorService.delete_sensor(db, sensor_id)
    if result:
        return {"message": f"Sensor with ID {sensor_id} deleted successfully"}
    return {"message": f"Failed to delete sensor with ID {sensor_id}"}

@router.post("/alerts", response_model=AlertResponse, operation_id="create_sensor_alert")
async def create_alert(
    alert: AlertCreate,
    db: Session = Depends(get_db)
):
    """
    Create a new alert for a sensor.
    """
    return await SensorService.create_alert(db, alert)


===== standard.py =====
from fastapi import APIRouter, Depends, Path, Query, HTTPException
from sqlalchemy.orm import Session
from typing import Dict, Any

from ...core.database import get_db
from ...services.standard_service import StandardDeviceService

router = APIRouter()


@router.get("/{device_id}/stats", operation_id="get_standard_device_stats")
async def get_device_stats(
        device_id: int = Path(..., description="The ID of the standard device"),
        db: Session = Depends(get_db)
):
    """
    Get all stats from a standard device using Glances API.

    This endpoint connects to the Glances web server running on the target device
    and retrieves all available system information. The Glances server must be
    running on the target device with the web server enabled (using 'glances -w').

    The default port for Glances web server is 61208. Make sure this port is
    accessible from the server running this API.

    Returns comprehensive system information including CPU, memory, disk, network,
    and process statistics.
    """
    result = await StandardDeviceService.get_device_stats(db, device_id)

    # If there's an error field, provide additional help in the response
    if "error" in result:
        result[
            "help"] = "Ensure that Glances is installed and running in web server mode on the target device. Run 'glances -w' on the target device to start the web server."

    return result


@router.get("/{device_id}/metrics/{metric}", operation_id="get_standard_device_metric")
async def get_specific_metric(
        device_id: int = Path(..., description="The ID of the standard device"),
        metric: str = Path(..., description="The specific metric to retrieve (e.g., cpu, memory, disk)"),
        db: Session = Depends(get_db)
):
    """
    Get a specific metric from a standard device.

    This endpoint connects to the Glances web server on the target device and
    retrieves a specific system metric. The Glances server must be running on
    the target device with the web server enabled (using 'glances -w').

    Common metric values:
    - cpu: CPU usage statistics
    - memory: Memory usage statistics
    - disk: Disk usage statistics
    - network: Network interface statistics
    - process: Process information
    - system: General system information

    For a complete list of available metrics, refer to the Glances API documentation.
    """
    result = await StandardDeviceService.get_specific_metric(db, device_id, metric)

    # If there's an error field, provide additional help in the response
    if "error" in result:
        result[
            "help"] = "Ensure that Glances is installed and running in web server mode on the target device. Run 'glances -w' on the target device to start the web server."

    return result


===== __init__.py =====


===== config.py =====
import os
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "Infrastruktúra Platform"
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///./infra_platform.db")
    PLUGINS_DIR: str = os.getenv("PLUGINS_DIR", "./plugins")

    class Config:
        env_file = ".env"


@lru_cache()
def get_settings():
    return Settings()


===== database.py =====
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import get_settings

settings = get_settings()

engine = create_engine(
    settings.DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


===== exceptions.py =====
from fastapi import HTTPException, status

class DeviceNotFoundException(HTTPException):
    def __init__(self, detail="Device not found"):
        super().__init__(status_code=status.HTTP_404_NOT_FOUND, detail=detail)

class PluginNotFoundException(HTTPException):
    def __init__(self, detail="Plugin not found"):
        super().__init__(status_code=status.HTTP_404_NOT_FOUND, detail=detail)

class PluginValidationError(HTTPException):
    def __init__(self, detail="Plugin validation failed"):
        super().__init__(status_code=status.HTTP_400_BAD_REQUEST, detail=detail)

class SensorNotFoundException(HTTPException):
    def __init__(self, detail="Sensor not found"):
        super().__init__(status_code=status.HTTP_404_NOT_FOUND, detail=detail)


===== __init__.py =====


===== device.py =====
from sqlalchemy import Column, Integer, String, ForeignKey, Enum, DateTime, Boolean, Text, JSON
from sqlalchemy.orm import relationship
from datetime import datetime
import enum
from ..core.database import Base


class DeviceType(str, enum.Enum):
    STANDARD = "standard"
    CUSTOM = "custom"


class OSType(str, enum.Enum):
    WINDOWS = "windows"
    MACOS = "macos"
    LINUX = "linux"


class Device(Base):
    __tablename__ = "devices"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    type = Column(Enum(DeviceType), nullable=False)
    ip_address = Column(String(50), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_active = Column(Boolean, default=True)

    standard_device = relationship("StandardDevice", back_populates="device", uselist=False,
                                   cascade="all, delete-orphan")
    custom_device = relationship("CustomDevice", back_populates="device", uselist=False, cascade="all, delete-orphan")
    sensors = relationship("Sensor", back_populates="device", cascade="all, delete-orphan")


class StandardDevice(Base):
    __tablename__ = "standard_devices"

    id = Column(Integer, primary_key=True, index=True)
    device_id = Column(Integer, ForeignKey("devices.id"), unique=True)
    os_type = Column(Enum(OSType), nullable=False)
    hostname = Column(String(255), nullable=False)

    device = relationship("Device", back_populates="standard_device")


class CustomDevice(Base):
    __tablename__ = "custom_devices"

    id = Column(Integer, primary_key=True, index=True)
    device_id = Column(Integer, ForeignKey("devices.id"), unique=True)
    plugin_id = Column(Integer, ForeignKey("plugins.id"))
    connection_params = Column(JSON, default={})

    device = relationship("Device", back_populates="custom_device")
    plugin = relationship("Plugin", back_populates="custom_devices")


===== plugin.py =====
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, JSON
from sqlalchemy.orm import relationship
from datetime import datetime
from ..core.database import Base


class Plugin(Base):
    __tablename__ = "plugins"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False, unique=True)
    description = Column(Text, nullable=True)
    version = Column(String(50), nullable=False)
    author = Column(String(255), nullable=True)
    code = Column(Text, nullable=False)
    ui_schema = Column(JSON, default={})
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_active = Column(Boolean, default=True)

    custom_devices = relationship("CustomDevice", back_populates="plugin")


===== sensor.py =====
from sqlalchemy import Column, Integer, String, ForeignKey, Enum, DateTime, Boolean, Text, JSON, Float
from sqlalchemy.orm import relationship
from datetime import datetime
import enum
from ..core.database import Base


class AlertLevel(str, enum.Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class Sensor(Base):
    __tablename__ = "sensors"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    device_id = Column(Integer, ForeignKey("devices.id"))
    metric_key = Column(String(255), nullable=False)  # A monitorozott metrika azonosítója
    alert_condition = Column(String(255), nullable=False)  # pl. ">90", "<5"
    alert_level = Column(Enum(AlertLevel), default=AlertLevel.WARNING)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_active = Column(Boolean, default=True)

    device = relationship("Device", back_populates="sensors")
    alerts = relationship("Alert", back_populates="sensor", cascade="all, delete-orphan")


class Alert(Base):
    __tablename__ = "alerts"

    id = Column(Integer, primary_key=True, index=True)
    sensor_id = Column(Integer, ForeignKey("sensors.id"))
    value = Column(Float, nullable=False)
    message = Column(Text, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)
    is_resolved = Column(Boolean, default=False)

    sensor = relationship("Sensor", back_populates="alerts")


===== __init__.py =====


===== base.py =====
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional


class BasePlugin(ABC):
    """Base class for all custom device plugins."""

    @property
    @abstractmethod
    def name(self) -> str:
        """Plugin name"""
        pass

    @property
    @abstractmethod
    def version(self) -> str:
        """Plugin version"""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Plugin description"""
        pass

    @property
    def ui_schema(self) -> Dict[str, Any]:
        """UI schema for rendering frontend components"""
        return {}

    @abstractmethod
    async def connect(self, params: Dict[str, Any]) -> bool:
        """Connect to the device"""
        pass

    @abstractmethod
    async def get_status(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Get device status"""
        pass

    @abstractmethod
    async def get_metrics(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Get device metrics"""
        pass

    def get_operations(self) -> List[Dict[str, Any]]:
        """Return available operations for this plugin"""
        return []

    async def execute_operation(self, operation_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute custom operation"""
        raise NotImplementedError(f"Operation {operation_id} not implemented")


===== loader.py =====
import os
import importlib.util
import sys
from typing import Dict, List, Type, Optional
from .base import BasePlugin
from .validator import load_plugin_class
from ..models.plugin import Plugin
from sqlalchemy.orm import Session


class PluginLoader:
    """
    Plugin loader responsible for loading and managing plugins.
    """
    _instance = None
    _plugins: Dict[int, Type[BasePlugin]] = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(PluginLoader, cls).__new__(cls)
        return cls._instance

    def get_plugin_class(self, plugin_id: int) -> Optional[Type[BasePlugin]]:
        """Get plugin class by ID"""
        return self._plugins.get(plugin_id)

    def load_plugins(self, db: Session) -> None:
        """Load all active plugins from database"""
        plugins = db.query(Plugin).filter(Plugin.is_active == True).all()

        for plugin in plugins:
            try:
                plugin_class = load_plugin_class(plugin.code)
                self._plugins[plugin.id] = plugin_class
            except Exception as e:
                print(f"Error loading plugin {plugin.name}: {str(e)}")

    def reload_plugin(self, db: Session, plugin_id: int) -> bool:
        """Reload a specific plugin"""
        plugin = db.query(Plugin).filter(Plugin.id == plugin_id, Plugin.is_active == True).first()
        if not plugin:
            return False

        try:
            plugin_class = load_plugin_class(plugin.code)
            self._plugins[plugin.id] = plugin_class
            return True
        except Exception as e:
            print(f"Error reloading plugin {plugin.name}: {str(e)}")
            return False


===== validator.py =====
import ast
import inspect
from typing import Dict, Any, List, Tuple, Optional
from .base import BasePlugin


def validate_plugin_code(code: str) -> Tuple[bool, Optional[str]]:
    """
    Validate plugin code for security and correctness.

    Args:
        code: The Python code to validate

    Returns:
        Tuple of (is_valid, error_message)
    """
    # Check for syntax errors
    try:
        ast.parse(code)
    except SyntaxError as e:
        return False, f"Syntax error: {str(e)}"

    # Check for dangerous imports
    tree = ast.parse(code)
    imports = []

    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for name in node.names:
                imports.append(name.name)
        elif isinstance(node, ast.ImportFrom):
            imports.append(node.module)

    blacklist = ['os', 'subprocess', 'sys', 'shutil', 'requests']
    for dangerous in blacklist:
        if any(imp == dangerous or (imp and imp.startswith(f"{dangerous}.")) for imp in imports):
            return False, f"Dangerous import detected: {dangerous}"

    # Check that the plugin inherits from BasePlugin
    class_defs = [node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]
    has_plugin_class = False

    for class_def in class_defs:
        for base in class_def.bases:
            if isinstance(base, ast.Name) and base.id == 'BasePlugin':
                has_plugin_class = True
                break

    if not has_plugin_class:
        return False, "No class inheriting from BasePlugin found"

    return True, None


def load_plugin_class(code: str) -> type[BasePlugin]:
    """
    Load a plugin class from code string.

    Args:
        code: The Python code containing the plugin class

    Returns:
        The plugin class
    """
    namespace = {}
    exec(f"from app.plugins.base import BasePlugin\n{code}", namespace)

    # Find the class that inherits from BasePlugin
    for name, obj in namespace.items():
        if (inspect.isclass(obj) and
                issubclass(obj, BasePlugin) and
                obj is not BasePlugin):
            return obj

    raise ValueError("No valid plugin class found")


===== __init__.py =====


===== device.py =====
from pydantic import BaseModel, Field, IPvAnyAddress
from typing import Optional, List, Dict, Any, Union
from datetime import datetime
from enum import Enum

class DeviceType(str, Enum):
    STANDARD = "standard"
    CUSTOM = "custom"

class OSType(str, Enum):
    WINDOWS = "windows"
    MACOS = "macos"
    LINUX = "linux"

# Base schemas
class DeviceBase(BaseModel):
    name: str
    description: Optional[str] = None
    ip_address: IPvAnyAddress

class StandardDeviceBase(BaseModel):
    os_type: OSType
    hostname: str


class CustomDeviceBase(BaseModel):
    plugin_id: int
    connection_params: Dict[str, Any] = {}

# Create schemas
class DeviceCreate(DeviceBase):
    type: DeviceType
    standard_device: Optional[StandardDeviceBase] = None
    custom_device: Optional[CustomDeviceBase] = None

# Update schemas
class DeviceUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    ip_address: Optional[IPvAnyAddress] = None
    is_active: Optional[bool] = None

class StandardDeviceUpdate(BaseModel):
    os_type: Optional[OSType] = None
    hostname: Optional[str] = None

class CustomDeviceUpdate(BaseModel):
    plugin_id: Optional[int] = None
    connection_params: Optional[Dict[str, Any]] = None

# Response schemas
class StandardDeviceResponse(StandardDeviceBase):
    id: int

    class Config:
        from_attributes = True

class CustomDeviceResponse(CustomDeviceBase):
    id: int
    plugin_name: Optional[str] = None

    class Config:
        from_attributes = True

class DeviceResponse(DeviceBase):
    id: int
    type: DeviceType
    is_active: bool
    created_at: datetime
    updated_at: datetime
    standard_device: Optional[StandardDeviceResponse] = None
    custom_device: Optional[CustomDeviceResponse] = None

    class Config:
        from_attributes = True


===== plugin.py =====
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from datetime import datetime

# Base schema
class PluginBase(BaseModel):
    name: str
    description: Optional[str] = None
    version: str
    author: Optional[str] = None

# Create schema
class PluginCreate(PluginBase):
    code: str
    ui_schema: Dict[str, Any] = {}

# Update schema
class PluginUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    version: Optional[str] = None
    author: Optional[str] = None
    code: Optional[str] = None
    ui_schema: Optional[Dict[str, Any]] = None
    is_active: Optional[bool] = None

# Response schema
class PluginResponse(PluginBase):
    id: int
    code: str
    ui_schema: Dict[str, Any]
    created_at: datetime
    updated_at: datetime
    is_active: bool

    class Config:
        from_attributes = True


===== sensor.py =====
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from enum import Enum

class AlertLevel(str, Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"

# Base schemas
class SensorBase(BaseModel):
    name: str
    description: Optional[str] = None
    metric_key: str
    alert_condition: str
    alert_level: AlertLevel = AlertLevel.WARNING

# Create schema
class SensorCreate(SensorBase):
    device_id: int

# Update schema
class SensorUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    metric_key: Optional[str] = None
    alert_condition: Optional[str] = None
    alert_level: Optional[AlertLevel] = None
    is_active: Optional[bool] = None

# Alert schemas
class AlertBase(BaseModel):
    value: float
    message: str
    is_resolved: bool = False

class AlertCreate(AlertBase):
    sensor_id: int

class AlertResponse(AlertBase):
    id: int
    sensor_id: int
    timestamp: datetime

    class Config:
        from_attributes = True

# Response schema
class SensorResponse(SensorBase):
    id: int
    device_id: int
    created_at: datetime
    updated_at: datetime
    is_active: bool
    alerts: List[AlertResponse] = []

    class Config:
        from_attributes = True


===== __init__.py =====


===== custom_service.py =====
from sqlalchemy.orm import Session
from typing import Dict, Any, List, Optional
from ..models.device import Device, CustomDevice, DeviceType
from ..core.exceptions import DeviceNotFoundException
from ..plugins.loader import PluginLoader


class CustomDeviceService:
    @staticmethod
    async def get_device_status(db: Session, device_id: int) -> Dict[str, Any]:
        """
        Get status from a custom device using its plugin
        """
        # Fetch device from database
        device = db.query(Device).filter(
            Device.id == device_id,
            Device.type == DeviceType.CUSTOM,
            Device.is_active == True
        ).first()

        if not device or not device.custom_device:
            raise DeviceNotFoundException(f"Custom device with ID {device_id} not found")

        # Get plugin
        plugin_loader = PluginLoader()
        plugin_class = plugin_loader.get_plugin_class(device.custom_device.plugin_id)

        if not plugin_class:
            return {"error": "Plugin not loaded"}

        # Create plugin instance and connect
        try:
            plugin = plugin_class()
            connection_params = device.custom_device.connection_params

            # Connect to device
            connected = await plugin.connect(connection_params)
            if not connected:
                return {"error": "Failed to connect to device"}

            # Get status
            status = await plugin.get_status(connection_params)
            return status
        except Exception as e:
            return {"error": f"Error connecting to device: {str(e)}"}

    @staticmethod
    async def get_device_metrics(db: Session, device_id: int) -> Dict[str, Any]:
        """
        Get metrics from a custom device using its plugin
        """
        # Fetch device from database
        device = db.query(Device).filter(
            Device.id == device_id,
            Device.type == DeviceType.CUSTOM,
            Device.is_active == True
        ).first()

        if not device or not device.custom_device:
            raise DeviceNotFoundException(f"Custom device with ID {device_id} not found")

        # Get plugin
        plugin_loader = PluginLoader()
        plugin_class = plugin_loader.get_plugin_class(device.custom_device.plugin_id)

        if not plugin_class:
            return {"error": "Plugin not loaded"}

        # Create plugin instance and connect
        try:
            plugin = plugin_class()
            connection_params = device.custom_device.connection_params

            # Connect to device
            connected = await plugin.connect(connection_params)
            if not connected:
                return {"error": "Failed to connect to device"}

            # Get metrics
            metrics = await plugin.get_metrics(connection_params)
            return metrics
        except Exception as e:
            return {"error": f"Error retrieving device metrics: {str(e)}"}

    @staticmethod
    async def execute_operation(
            db: Session,
            device_id: int,
            operation_id: str,
            params: Dict[str, Any] = {}
    ) -> Dict[str, Any]:
        """
        Execute a custom operation on a device
        """
        # Fetch device from database
        device = db.query(Device).filter(
            Device.id == device_id,
            Device.type == DeviceType.CUSTOM,
            Device.is_active == True
        ).first()

        if not device or not device.custom_device:
            raise DeviceNotFoundException(f"Custom device with ID {device_id} not found")

        # Get plugin
        plugin_loader = PluginLoader()
        plugin_class = plugin_loader.get_plugin_class(device.custom_device.plugin_id)

        if not plugin_class:
            return {"error": "Plugin not loaded"}

        # Create plugin instance and connect
        try:
            plugin = plugin_class()
            connection_params = device.custom_device.connection_params

            # Connect to device
            connected = await plugin.connect(connection_params)
            if not connected:
                return {"error": "Failed to connect to device"}

            # Execute operation
            result = await plugin.execute_operation(
                operation_id=operation_id,
                params={**connection_params, **params}
            )
            return result
        except NotImplementedError:
            return {"error": f"Operation {operation_id} not implemented by this plugin"}
        except Exception as e:
            return {"error": f"Error executing operation: {str(e)}"}


===== device_service.py =====
from sqlalchemy.orm import Session
from typing import List, Optional, Dict, Any, Union
from ..models.device import Device, StandardDevice, CustomDevice, DeviceType
from ..schemas.device import DeviceCreate, DeviceUpdate, StandardDeviceUpdate, CustomDeviceUpdate
from ..core.exceptions import DeviceNotFoundException, PluginNotFoundException
from ..models.plugin import Plugin


class DeviceService:
    @staticmethod
    async def get_devices(db: Session, skip: int = 0, limit: int = 100) -> List[Device]:
        """Get all devices with pagination"""
        return db.query(Device).offset(skip).limit(limit).all()

    @staticmethod
    async def get_device(db: Session, device_id: int) -> Device:
        """Get a device by ID"""
        device = db.query(Device).filter(Device.id == device_id).first()
        if not device:
            raise DeviceNotFoundException(f"Device with ID {device_id} not found")
        return device

    @staticmethod
    async def create_device(db: Session, device_data: DeviceCreate) -> Device:
        """Create a new device with associated standard or custom device"""
        # Create base device
        device = Device(
            name=device_data.name,
            description=device_data.description,
            type=device_data.type,
            ip_address=str(device_data.ip_address)
        )

        db.add(device)
        db.flush()  # Get the device ID

        # Create associated device based on type
        if device_data.type == DeviceType.STANDARD:
            if not device_data.standard_device:
                db.rollback()
                raise ValueError("Standard device data is required for device type STANDARD")

            std_device = StandardDevice(
                device_id=device.id,
                os_type=device_data.standard_device.os_type,
                hostname=device_data.standard_device.hostname,
            )
            db.add(std_device)

        elif device_data.type == DeviceType.CUSTOM:
            if not device_data.custom_device:
                db.rollback()
                raise ValueError("Custom device data is required for device type CUSTOM")

            # Verify plugin exists
            plugin = db.query(Plugin).filter(
                Plugin.id == device_data.custom_device.plugin_id,
                Plugin.is_active == True
            ).first()

            if not plugin:
                db.rollback()
                raise PluginNotFoundException(
                    f"Plugin with ID {device_data.custom_device.plugin_id} not found or not active")

            custom_device = CustomDevice(
                device_id=device.id,
                plugin_id=device_data.custom_device.plugin_id,
                connection_params=device_data.custom_device.connection_params
            )
            db.add(custom_device)

        db.commit()
        db.refresh(device)

        if device.type == DeviceType.CUSTOM and device.custom_device:
            plugin = db.query(Plugin).filter(Plugin.id == device.custom_device.plugin_id).first()
            if plugin:
                setattr(device.custom_device, "plugin_name", plugin.name)

        return device

    @staticmethod
    async def update_device(
            db: Session,
            device_id: int,
            device_data: DeviceUpdate,
            standard_data: Optional[StandardDeviceUpdate] = None,
            custom_data: Optional[CustomDeviceUpdate] = None
    ) -> Device:
        """Update a device and its associated standard or custom device"""
        device = await DeviceService.get_device(db, device_id)

        # Update base device fields
        for key, value in device_data.dict(exclude_unset=True).items():
            setattr(device, key, value)

        # Update specific device type data
        if device.type == DeviceType.STANDARD and standard_data:
            if not device.standard_device:
                raise ValueError(f"Device {device_id} does not have associated standard device data")

            for key, value in standard_data.dict(exclude_unset=True).items():
                setattr(device.standard_device, key, value)

        elif device.type == DeviceType.CUSTOM and custom_data:
            if not device.custom_device:
                raise ValueError(f"Device {device_id} does not have associated custom device data")

            if custom_data.plugin_id:
                # Verify plugin exists if changing
                plugin = db.query(Plugin).filter(
                    Plugin.id == custom_data.plugin_id,
                    Plugin.is_active == True
                ).first()

                if not plugin:
                    raise PluginNotFoundException(f"Plugin with ID {custom_data.plugin_id} not found or not active")

            for key, value in custom_data.dict(exclude_unset=True).items():
                setattr(device.custom_device, key, value)

        db.commit()
        db.refresh(device)
        return device

    @staticmethod
    async def delete_device(db: Session, device_id: int) -> bool:
        """Delete a device"""
        device = await DeviceService.get_device(db, device_id)
        db.delete(device)
        db.commit()
        return True


===== plugin_service.py =====
from sqlalchemy.orm import Session
from typing import List, Dict, Any, Optional
from ..models.plugin import Plugin
from ..schemas.plugin import PluginCreate, PluginUpdate
from ..plugins.validator import validate_plugin_code
from ..plugins.loader import PluginLoader
from ..core.exceptions import PluginNotFoundException, PluginValidationError


class PluginService:
    @staticmethod
    async def get_plugins(db: Session, skip: int = 0, limit: int = 100) -> List[Plugin]:
        """Get all plugins with pagination"""
        return db.query(Plugin).offset(skip).limit(limit).all()

    @staticmethod
    async def get_plugin(db: Session, plugin_id: int) -> Plugin:
        """Get a plugin by ID"""
        plugin = db.query(Plugin).filter(Plugin.id == plugin_id).first()
        if not plugin:
            raise PluginNotFoundException(f"Plugin with ID {plugin_id} not found")
        return plugin

    @staticmethod
    async def create_plugin(db: Session, plugin_data: PluginCreate) -> Plugin:
        """
        Create a new plugin after validating the code
        """
        # Validate plugin code
        is_valid, error_message = validate_plugin_code(plugin_data.code)
        if not is_valid:
            raise PluginValidationError(error_message)

        # Create plugin
        plugin = Plugin(
            name=plugin_data.name,
            description=plugin_data.description,
            version=plugin_data.version,
            author=plugin_data.author,
            code=plugin_data.code,
            ui_schema=plugin_data.ui_schema
        )

        db.add(plugin)
        db.commit()
        db.refresh(plugin)

        # Reload plugins
        plugin_loader = PluginLoader()
        plugin_loader.reload_plugin(db, plugin.id)

        return plugin

    @staticmethod
    async def update_plugin(db: Session, plugin_id: int, plugin_data: PluginUpdate) -> Plugin:
        """
        Update a plugin after validating the code if provided
        """
        plugin = await PluginService.get_plugin(db, plugin_id)

        # If code is being updated, validate it
        if plugin_data.code is not None:
            is_valid, error_message = validate_plugin_code(plugin_data.code)
            if not is_valid:
                raise PluginValidationError(error_message)

        # Update fields
        for key, value in plugin_data.dict(exclude_unset=True).items():
            setattr(plugin, key, value)

        db.commit()
        db.refresh(plugin)

        # Reload plugin if it's active
        if plugin.is_active:
            plugin_loader = PluginLoader()
            plugin_loader.reload_plugin(db, plugin.id)

        return plugin

    @staticmethod
    async def delete_plugin(db: Session, plugin_id: int) -> bool:
        """Delete a plugin"""
        plugin = await PluginService.get_plugin(db, plugin_id)
        db.delete(plugin)
        db.commit()
        return True


===== sensor_service.py =====
from sqlalchemy.orm import Session
from typing import List, Dict, Any, Optional
from ..models.sensor import Sensor, Alert, AlertLevel
from ..models.device import Device
from ..schemas.sensor import SensorCreate, SensorUpdate, AlertCreate
from ..core.exceptions import SensorNotFoundException, DeviceNotFoundException
import datetime


class SensorService:
    @staticmethod
    async def get_sensors(db: Session, skip: int = 0, limit: int = 100) -> List[Sensor]:
        """Get all sensors with pagination"""
        return db.query(Sensor).offset(skip).limit(limit).all()

    @staticmethod
    async def get_device_sensors(db: Session, device_id: int) -> List[Sensor]:
        """Get all sensors for a specific device"""
        device = db.query(Device).filter(Device.id == device_id).first()
        if not device:
            raise DeviceNotFoundException(f"Device with ID {device_id} not found")

        return db.query(Sensor).filter(Sensor.device_id == device_id).all()

    @staticmethod
    async def get_sensor(db: Session, sensor_id: int) -> Sensor:
        """Get a sensor by ID"""
        sensor = db.query(Sensor).filter(Sensor.id == sensor_id).first()
        if not sensor:
            raise SensorNotFoundException(f"Sensor with ID {sensor_id} not found")
        return sensor

    @staticmethod
    async def create_sensor(db: Session, sensor_data: SensorCreate) -> Sensor:
        """Create a new sensor"""
        # Verify device exists
        device = db.query(Device).filter(Device.id == sensor_data.device_id).first()
        if not device:
            raise DeviceNotFoundException(f"Device with ID {sensor_data.device_id} not found")

        # Create sensor
        sensor = Sensor(
            name=sensor_data.name,
            description=sensor_data.description,
            device_id=sensor_data.device_id,
            metric_key=sensor_data.metric_key,
            alert_condition=sensor_data.alert_condition,
            alert_level=sensor_data.alert_level
        )

        db.add(sensor)
        db.commit()
        db.refresh(sensor)
        return sensor

    @staticmethod
    async def update_sensor(db: Session, sensor_id: int, sensor_data: SensorUpdate) -> Sensor:
        """Update a sensor"""
        sensor = await SensorService.get_sensor(db, sensor_id)

        # Update fields
        for key, value in sensor_data.dict(exclude_unset=True).items():
            setattr(sensor, key, value)

        db.commit()
        db.refresh(sensor)
        return sensor

    @staticmethod
    async def delete_sensor(db: Session, sensor_id: int) -> bool:
        """Delete a sensor"""
        sensor = await SensorService.get_sensor(db, sensor_id)
        db.delete(sensor)
        db.commit()
        return True

    @staticmethod
    async def create_alert(db: Session, alert_data: AlertCreate) -> Alert:
        """Create a new alert for a sensor"""
        # Verify sensor exists
        sensor = db.query(Sensor).filter(Sensor.id == alert_data.sensor_id).first()
        if not sensor:
            raise SensorNotFoundException(f"Sensor with ID {alert_data.sensor_id} not found")

        # Create alert
        alert = Alert(
            sensor_id=alert_data.sensor_id,
            value=alert_data.value,
            message=alert_data.message,
            is_resolved=alert_data.is_resolved
        )

        db.add(alert)
        db.commit()
        db.refresh(alert)
        return alert

    @staticmethod
    async def check_metric_against_condition(
            metric_value: float,
            condition: str
    ) -> bool:
        """
        Check if a metric value meets an alert condition

        Condition format examples: ">90", "<5", "==0", ">=75"
        """
        if condition.startswith(">"):
            if condition.startswith(">="):
                threshold = float(condition[2:])
                return metric_value >= threshold
            else:
                threshold = float(condition[1:])
                return metric_value > threshold
        elif condition.startswith("<"):
            if condition.startswith("<="):
                threshold = float(condition[2:])
                return metric_value <= threshold
            else:
                threshold = float(condition[1:])
                return metric_value < threshold
        elif condition.startswith("=="):
            threshold = float(condition[2:])
            return metric_value == threshold
        elif condition.startswith("!="):
            threshold = float(condition[2:])
            return metric_value != threshold

        # Default case if format not recognized
        return False


===== standard_service.py =====
import aiohttp
import json
from sqlalchemy.orm import Session
from typing import Dict, Any, Optional
from ..models.device import Device, StandardDevice, DeviceType
from ..core.exceptions import DeviceNotFoundException
from ..utils.monitoring import parse_glances_data


class StandardDeviceService:
    @staticmethod
    async def get_device_stats(db: Session, device_id: int) -> Dict[str, Any]:
        """
        Get stats from a standard device using Glances API
        """
        # Fetch device from database
        device = db.query(Device).filter(
            Device.id == device_id,
            Device.type == DeviceType.STANDARD,
            Device.is_active == True
        ).first()

        if not device or not device.standard_device:
            raise DeviceNotFoundException(f"Standard device with ID {device_id} not found")

        # Prepare Glances API URL - Glances generally runs on port 61208, not on SSH port
        std_device = device.standard_device
        glances_port = 61208  # Default Glances web server port
        base_url = f"http://{device.ip_address}:{glances_port}/api/4"

        # Fetch stats from Glances API
        async with aiohttp.ClientSession() as session:
            try:
                # Add timeout to avoid long waiting times
                async with session.get(f"{base_url}/all", timeout=5) as response:
                    if response.status != 200:
                        return {"error": f"Failed to fetch stats: HTTP {response.status}"}

                    data = await response.json()
                    return parse_glances_data(data)
            except aiohttp.ClientConnectorError as e:
                return {
                    "error": f"Failed to connect to Glances API at {base_url}/all. Make sure Glances is running in web server mode with: glances -w",
                    "details": str(e)
                }
            except aiohttp.ClientError as e:
                return {"error": f"Glances API request failed: {str(e)}"}
            except Exception as e:
                return {"error": f"Unexpected error: {str(e)}"}

    @staticmethod
    async def get_specific_metric(
            db: Session,
            device_id: int,
            metric: str
    ) -> Dict[str, Any]:
        """
        Get a specific metric from a standard device
        """
        # Fetch device from database
        device = db.query(Device).filter(
            Device.id == device_id,
            Device.type == DeviceType.STANDARD,
            Device.is_active == True
        ).first()

        if not device or not device.standard_device:
            raise DeviceNotFoundException(f"Standard device with ID {device_id} not found")

        # Prepare Glances API URL
        glances_port = 61208  # Default Glances web server port
        base_url = f"http://{device.ip_address}:{glances_port}/api/4"

        # Fetch specific metric
        async with aiohttp.ClientSession() as session:
            try:
                # Add timeout to avoid long waiting times
                async with session.get(f"{base_url}/{metric}", timeout=5) as response:
                    if response.status != 200:
                        return {"error": f"Failed to fetch metric: HTTP {response.status}"}

                    data = await response.json()
                    return {metric: data}
            except aiohttp.ClientConnectorError as e:
                return {
                    "error": f"Failed to connect to Glances API at {base_url}/{metric}. Make sure Glances is running in web server mode with: glances -w",
                    "details": str(e)
                }
            except aiohttp.ClientError as e:
                return {"error": f"Glances API request failed: {str(e)}"}
            except Exception as e:
                return {"error": f"Unexpected error: {str(e)}"}


===== __init__.py =====


===== helpers.py =====
import importlib.util
import sys
from pathlib import Path
from typing import Dict, Any, List, Tuple, Optional
import json


def safe_json_loads(json_str: str, default: Any = None) -> Any:
    """
    Safely load JSON string

    Args:
        json_str: JSON string to load
        default: Default value to return if loading fails

    Returns:
        Parsed JSON or default value
    """
    try:
        return json.loads(json_str)
    except (json.JSONDecodeError, TypeError):
        return default if default is not None else {}


def parse_condition(condition: str) -> Tuple[str, float]:
    """
    Parse alert condition string into operator and value

    Args:
        condition: Condition string (e.g., ">90", "<5")

    Returns:
        Tuple of (operator, value)
    """
    operators = [">=", "<=", "==", "!=", ">", "<"]

    for op in operators:
        if condition.startswith(op):
            try:
                value = float(condition[len(op):])
                return op, value
            except ValueError:
                break

    raise ValueError(f"Invalid condition format: {condition}")


def format_bytes(bytes_value: int) -> str:
    """
    Format bytes to human-readable string

    Args:
        bytes_value: Bytes value

    Returns:
        Formatted string (e.g., "1.23 GB")
    """
    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
    i = 0
    while bytes_value >= 1024 and i < len(suffixes) - 1:
        bytes_value /= 1024.0
        i += 1
    return f"{bytes_value:.2f} {suffixes[i]}"


===== monitoring.py =====
from typing import Dict, Any, List, Union


def parse_glances_data(data: Union[Dict[str, Any], List, Any]) -> Dict[str, Any]:
    """
    Parse and sanitize Glances data to extract key metrics

    Args:
        data: Raw Glances API response

    Returns:
        Dict containing key metrics in a structured format
    """
    # Check if data is not a dictionary
    if not isinstance(data, dict):
        # If it's a list, try to use the first item if it's a dict
        if isinstance(data, list) and len(data) > 0 and isinstance(data[0], dict):
            data = data[0]
        else:
            # Return an error if we can't process the data
            return {
                "error": "Unexpected response format from Glances API",
                "raw_data_type": str(type(data)),
                "raw_data_preview": str(data)[:200] if hasattr(data, "__str__") else "Not available"
            }

    result = {}

    # CPU metrics
    if "cpu" in data:
        cpu_data = data["cpu"]
        if isinstance(cpu_data, dict):
            result["cpu"] = {
                "usage": cpu_data.get("total", 0),
                "cores": [],
                "temperature": data.get("sensors", {}).get("temperatures", []) if isinstance(data.get("sensors"),
                                                                                             dict) else []
            }

            # Per-core data
            for key, value in cpu_data.items():
                if key.startswith("cpu_"):
                    try:
                        core_num = int(key.split("_")[1])
                        result["cpu"]["cores"].append({
                            "core": core_num,
                            "usage": value
                        })
                    except (ValueError, IndexError):
                        pass
        elif isinstance(cpu_data, (int, float)):
            # Handle case where cpu might be just a single value
            result["cpu"] = {
                "usage": cpu_data,
                "cores": [],
                "temperature": []
            }

    # Memory metrics
    if "mem" in data:
        mem_data = data["mem"]
        if isinstance(mem_data, dict):
            result["memory"] = {
                "total": mem_data.get("total", 0),
                "used": mem_data.get("used", 0),
                "free": mem_data.get("free", 0),
                "percent": mem_data.get("percent", 0)
            }
        else:
            # Handle case where memory info is not a dict
            result["memory"] = {
                "total": 0,
                "used": 0,
                "free": 0,
                "percent": 0,
                "raw_data": str(mem_data)[:100] if hasattr(mem_data, "__str__") else "Not available"
            }

    # Disk metrics
    if "fs" in data:
        fs_data = data["fs"]
        result["disk"] = []

        if isinstance(fs_data, list):
            for disk in fs_data:
                if isinstance(disk, dict):
                    result["disk"].append({
                        "device": disk.get("device_name", "unknown"),
                        "mountpoint": disk.get("mnt_point", ""),
                        "total": disk.get("size", 0),
                        "used": disk.get("used", 0),
                        "free": disk.get("free", 0),
                        "percent": disk.get("percent", 0)
                    })
        elif isinstance(fs_data, dict):
            # Single disk as dict
            result["disk"].append({
                "device": fs_data.get("device_name", "unknown"),
                "mountpoint": fs_data.get("mnt_point", ""),
                "total": fs_data.get("size", 0),
                "used": fs_data.get("used", 0),
                "free": fs_data.get("free", 0),
                "percent": fs_data.get("percent", 0)
            })

    # Network metrics
    if "network" in data:
        network_data = data["network"]
        result["network"] = []

        if isinstance(network_data, dict):
            for interface_name, interface_data in network_data.items():
                # Skip lo interface
                if interface_name == "lo":
                    continue

                if isinstance(interface_data, dict):
                    result["network"].append({
                        "interface": interface_name,
                        "rx": interface_data.get("rx", 0),
                        "tx": interface_data.get("tx", 0),
                        "rx_packets": interface_data.get("rx_packets", 0),
                        "tx_packets": interface_data.get("tx_packets", 0)
                    })
        elif isinstance(network_data, list):
            # If network data is a list of interfaces
            for interface in network_data:
                if isinstance(interface, dict) and "interface_name" in interface:
                    result["network"].append({
                        "interface": interface.get("interface_name", "unknown"),
                        "rx": interface.get("rx", 0),
                        "tx": interface.get("tx", 0),
                        "rx_packets": interface.get("rx_packets", 0),
                        "tx_packets": interface.get("tx_packets", 0)
                    })

    # Processes
    if "processcount" in data:
        proc_data = data["processcount"]
        if isinstance(proc_data, dict):
            result["processes"] = {
                "total": proc_data.get("total", 0),
                "running": proc_data.get("running", 0),
                "sleeping": proc_data.get("sleeping", 0),
                "thread": proc_data.get("thread", 0)
            }
        else:
            # Simple case where processcount might be just a number
            result["processes"] = {
                "total": proc_data if isinstance(proc_data, (int, float)) else 0
            }

    # System info
    if "system" in data:
        sys_data = data["system"]
        if isinstance(sys_data, dict):
            result["system"] = {
                "hostname": sys_data.get("hostname", ""),
                "os_name": sys_data.get("os_name", ""),
                "os_version": sys_data.get("os_version", ""),
                "uptime": sys_data.get("uptime", "")
            }
        else:
            result["system"] = {
                "raw_data": str(sys_data)[:100] if hasattr(sys_data, "__str__") else "Not available"
            }

    # If result is empty but data is not empty, include raw data preview
    if not result and data:
        result["raw_data_preview"] = str(data)[:500] if hasattr(data, "__str__") else "Not available"

    return result


===== __init__.py =====


